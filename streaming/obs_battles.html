<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fouler-Play OBS v2</title>
    <!-- Use a premium font -->
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0f0f1b;
            --accent-red: #ff2e63;
            --accent-blue: #08d9d6;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-main: #eaeaea;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: var(--bg-dark);
            font-family: 'Outfit', sans-serif;
            color: var(--text-main);
        }

        /* Main Layout */
        .app-container {
            display: flex;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .battle-slot {
            flex: 1;
            height: 100%;
            position: relative;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0f0f1b 100%);
        }

        #slot1,
        #slot2 {
            border-right: 1px solid var(--glass-border);
        }

        iframe {
            width: 100%;
            height: 100%;
            border: none;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        iframe.visible {
            opacity: 1;
        }

        /* Premium Overlay UI */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .slot-header {
            position: absolute;
            top: 30px;
            left: 30px;
            display: flex;
            align-items: center;
            gap: 15px;
            pointer-events: auto;
        }

        .badge {
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 800;
            letter-spacing: 1px;
            text-transform: uppercase;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
        }

        .badge.red {
            color: var(--accent-red);
            border-color: var(--accent-red);
            box-shadow: 0 0 15px rgba(255, 46, 99, 0.2);
        }

        .badge.blue {
            color: var(--accent-blue);
            border-color: var(--accent-blue);
            box-shadow: 0 0 15px rgba(8, 217, 214, 0.2);
        }

        .badge.purple {
            color: #bd93f9;
            border-color: #bd93f9;
            box-shadow: 0 0 15px rgba(189, 147, 249, 0.2);
        }

        .battle-card {
            position: absolute;
            bottom: 60px;
            left: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            padding: 20px 30px;
            border-radius: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transform: translateY(150%);
            transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1);
            pointer-events: auto;
        }

        .battle-card.show {
            transform: translateY(0);
        }

        .opp-info h4 {
            font-size: 12px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 4px;
        }

        .opp-info div {
            font-size: 24px;
            font-weight: 800;
            color: #fff;
        }

        .match-stats {
            text-align: right;
        }

        .match-stats .turn {
            font-size: 18px;
            font-weight: 600;
            color: var(--accent-blue);
        }

        /* Searching Animation (Sonar) */
        .searching-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-dark);
            z-index: 50;
            transition: opacity 0.5s;
        }

        .searching-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .sonar {
            width: 300px;
            height: 300px;
            position: relative;
            margin-bottom: 40px;
        }

        .sonar-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid var(--accent-blue);
            border-radius: 50%;
            opacity: 0;
            animation: sonar-ping 4s infinite linear;
        }

        .sonar-circle:nth-child(2) {
            animation-delay: 1s;
        }

        .sonar-circle:nth-child(3) {
            animation-delay: 2s;
        }

        .sonar-circle:nth-child(4) {
            animation-delay: 3s;
        }

        @keyframes sonar-ping {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }

            100% {
                width: 100%;
                height: 100%;
                opacity: 0;
            }
        }

        .sonar-scanner {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: conic-gradient(from 0deg, transparent 0deg, var(--accent-blue) 360deg);
            opacity: 0.1;
            border-radius: 50%;
            animation: rotate 4s linear infinite;
        }

        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .searching-text {
            font-size: 32px;
            font-weight: 800;
            letter-spacing: 4px;
            text-transform: uppercase;
            color: var(--accent-blue);
            text-shadow: 0 0 20px rgba(8, 217, 214, 0.4);
        }

        /* Status Bar V2 */
        .bottom-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border-top: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 40px;
            z-index: 200;
        }

        .stat-group {
            display: flex;
            gap: 25px;
            font-size: 14px;
            font-weight: 600;
        }

        .stat-item span {
            color: #888;
            margin-right: 8px;
        }

        .stat-item b {
            color: #fff;
        }

        .conn-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: #888;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff4b2b;
        }

        .dot.online {
            background: #4ade80;
            box-shadow: 0 0 10px #4ade80;
        }

        /* Debug Panel */
        .debug-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 999;
            background: rgba(0, 0, 0, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 10px 12px;
            font-family: "Consolas", "Courier New", monospace;
            font-size: 12px;
            color: #e5e5e5;
            max-width: 360px;
            line-height: 1.4;
            pointer-events: none;
        }

        .debug-panel.hidden {
            display: none;
        }

        .debug-title {
            font-weight: 700;
            margin-bottom: 6px;
            color: #9ae6b4;
        }

        /* Single Slot Mode Support */
        body.single-slot-1 #slot2,
        body.single-slot-1 #slot2 {
            display: none;
        }

        body.single-slot-2 #slot1 {
            display: none;
        }

        /* Max Slots Support (from /state max_slots) - only 2 slots now */
        body.max-slots-1 #slot2,
        body.max-slots-1 #slot3 {
            display: none;
        }

        body.max-slots-2 #slot3 {
            display: none;
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Slot 1 -->
        <div class="battle-slot" id="slot1">
            <div class="searching-overlay" id="searching1">
                <div class="sonar">
                    <div class="sonar-scanner"></div>
                    <div class="sonar-circle"></div>
                    <div class="sonar-circle"></div>
                    <div class="sonar-circle"></div>
                    <div class="sonar-circle"></div>
                </div>
                <div class="searching-text">SCANNING...</div>
            </div>

            <iframe id="frame1"></iframe>

            <div class="ui-layer">
                <div class="slot-header">
                    <div class="badge red">WORKER 01</div>
                    <div class="badge">LIVE BATTLE</div>
                </div>
                <div class="battle-card" id="card1">
                    <div class="opp-info">
                        <h4>Opponent</h4>
                        <div id="opp1">----------</div>
                    </div>
                    <div class="match-stats">
                        <div class="turn">ACTIVE MATCH</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slot 2 -->
        <div class="battle-slot" id="slot2">
            <div class="searching-overlay" id="searching2">
                <div class="sonar">
                    <div class="sonar-scanner"></div>
                    <div class="sonar-circle"></div>
                    <div class="sonar-circle"></div>
                    <div class="sonar-circle"></div>
                    <div class="sonar-circle"></div>
                </div>
                <div class="searching-text">SCANNING...</div>
            </div>

            <iframe id="frame2"></iframe>

            <div class="ui-layer">
                <div class="slot-header">
                    <div class="badge blue">WORKER 02</div>
                    <div class="badge">LIVE BATTLE</div>
                </div>
                <div class="battle-card" id="card2">
                    <div class="opp-info">
                        <h4>Opponent</h4>
                        <div id="opp2">----------</div>
                    </div>
                    <div class="match-stats">
                        <div class="turn">ACTIVE MATCH</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Slot 3 -->
        <div class="battle-slot" id="slot3">
            <div class="searching-overlay" id="searching3">
                <div class="sonar">
                    <div class="sonar-scanner"></div>
                    <div class="sonar-circle"></div>
                    <div class="sonar-circle"></div>
                    <div class="sonar-circle"></div>
                    <div class="sonar-circle"></div>
                </div>
                <div class="searching-text">SCANNING...</div>
            </div>

            <iframe id="frame3"></iframe>

            <div class="ui-layer">
                <div class="slot-header">
                    <div class="badge purple">WORKER 03</div>
                    <div class="badge">LIVE BATTLE</div>
                </div>
                <div class="battle-card" id="card3">
                    <div class="opp-info">
                        <h4>Opponent</h4>
                        <div id="opp3">----------</div>
                    </div>
                    <div class="match-stats">
                        <div class="turn">ACTIVE MATCH</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="bottom-bar">
        <div class="stat-group">
            <div class="stat-item"><span>WINS</span><b id="totalWins">0</b></div>
            <div class="stat-item"><span>LOSSES</span><b id="totalLosses">0</b></div>
            <div class="stat-item"><span>ELO</span><b id="totalElo">----</b></div>
        </div>

        <div class="conn-status">
            <div class="dot" id="connDot"></div>
            <span id="connText">OFFLINE</span>
        </div>
    </div>

    <div id="debugPanel" class="debug-panel hidden">
        <div class="debug-title">OBS DEBUG</div>
        <div id="debugConn">WS: -</div>
        <div id="debugUpdated">Last: -</div>
        <div id="debugSlot1">Slot1: -</div>
        <div id="debugSlot2">Slot2: -</div>
        <div id="debugSlot3">Slot3: -</div>
    </div>

    <script>
        const host = window.location.hostname;
        const port = window.location.port || '8777';
        const wsUrl = `ws://${host}:${port}/ws`;
        const httpBase = `http://${host}:${port}`;
        let socket = null;
        let wsOnline = false;
        const currentBattles = {}; // Tracking battle tags to slots
        const currentBattleUrls = {}; // Canonical battle URL per slot
        const slotReloadTimers = { 1: [], 2: [], 3: [] };
        let maxSlots = 3; // 3 concurrent battles

        // Single slot mode
        const params = new URLSearchParams(window.location.search);
        const forceSlot = params.get('slot');
        const debugEnabled = params.get('debug') === '1';
        if (debugEnabled) {
            document.getElementById('debugPanel').classList.remove('hidden');
        }
        function removeSlots(nums) {
            nums.forEach((num) => {
                const slot = document.getElementById(`slot${num}`);
                if (slot) {
                    slot.remove();
                }
            });
        }

        if (forceSlot === '1') {
            document.body.classList.add('single-slot-1');
            removeSlots([2, 3]);
            maxSlots = 1;
        }
        if (forceSlot === '2') {
            document.body.classList.add('single-slot-2');
            removeSlots([1, 3]);
            maxSlots = 1;
        }
        if (forceSlot === '3') {
            document.body.classList.add('single-slot-3');
            removeSlots([1, 2]);
            maxSlots = 1;
        }

        function connect() {
            console.log("Connecting to WebSocket...", wsUrl);
            socket = new WebSocket(wsUrl);

            socket.onopen = () => {
                wsOnline = true;
                document.getElementById('connDot').classList.add('online');
                document.getElementById('connText').textContent = 'REAL-TIME CONNECTED';
            };

            socket.onerror = () => {
                try { socket.close(); } catch (e) { }
            };

            socket.onclose = () => {
                wsOnline = false;
                document.getElementById('connDot').classList.remove('online');
                document.getElementById('connText').textContent = 'OFFLINE - RETRYING...';
                setTimeout(connect, 2000);
            };

            socket.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                handleEvent(msg);
            };
        }

        function handleEvent(msg) {
            const { type, payload } = msg;
            if (type === 'INIT' || type === 'STATE_UPDATE') {
                if (payload && payload.status) {
                    updateStats(payload.status);
                }
                if (payload && payload.max_slots) {
                    applyMaxSlots(payload.max_slots);
                }
                if (payload && payload.battles) {
                    syncSlots(payload.battles);
                }
                updateDebug(payload);
            }
        }

        function applyMaxSlots(value) {
            if (forceSlot) {
                return;
            }
            const parsed = parseInt(value);
            if (Number.isNaN(parsed) || parsed <= 0) {
                return;
            }
            maxSlots = Math.max(1, Math.min(3, parsed));
            document.body.classList.remove('max-slots-1', 'max-slots-2');
            if (maxSlots === 1) {
                document.body.classList.add('max-slots-1');
            } else if (maxSlots === 2) {
                document.body.classList.add('max-slots-2');
            }
        }

        function withCacheBust(url, cacheBust) {
            if (!cacheBust) return url;
            const parts = url.split('#');
            const base = parts[0];
            const hash = parts.length > 1 ? `#${parts.slice(1).join('#')}` : '';
            const joiner = base.includes('?') ? '&' : '?';
            return `${base}${joiner}r=${cacheBust}${hash}`;
        }

        function stripCacheBust(url) {
            if (!url) return url;
            const parts = url.split('#');
            const base = parts[0];
            const hash = parts.length > 1 ? `#${parts.slice(1).join('#')}` : '';
            const baseParts = base.split('?');
            if (baseParts.length < 2) {
                return url;
            }
            const path = baseParts[0];
            const params = new URLSearchParams(baseParts[1]);
            params.delete('r');
            const query = params.toString();
            return `${path}${query ? `?${query}` : ''}${hash}`;
        }

        function buildBattleUrl(bid, cacheBust = null) {
            // Use direct URL - ~~showdown triggers "visit showdown directly" frame check.
            // NOTE: iframes may still be blocked by Showdown's X-Frame-Options.
            // Prefer direct OBS browser sources (see serve_obs_page.py) instead of this page.
            const url = `https://play.pokemonshowdown.com/${bid}`;
            return withCacheBust(url, cacheBust);
        }

        function getBattleUrl(battle) {
            if (!battle) return null;
            const raw = battle.url || buildBattleUrl(battle.id);
            return stripCacheBust(raw);
        }

        function clearSlotReloadTimers(num) {
            if (!slotReloadTimers[num]) return;
            slotReloadTimers[num].forEach((t) => clearTimeout(t));
            slotReloadTimers[num] = [];
        }

        function scheduleInviteReload(num, bid, baseUrl) {
            clearSlotReloadTimers(num);
            // Multiple delayed reloads to ensure spectator invite has taken effect
            const delays = [4000, 10000, 18000, 30000];
            delays.forEach((delay, idx) => {
                const timer = setTimeout(() => {
                    if (currentBattles[`slot${num}`] !== bid) return;
                    const frame = document.getElementById(`frame${num}`);
                    if (!frame) return;
                    const refreshBase = baseUrl || buildBattleUrl(bid);
                    frame.src = withCacheBust(refreshBase, Date.now() + idx);
                }, delay);
                slotReloadTimers[num].push(timer);
            });
        }


        function updateSlot(num, battle) {
            const frame = document.getElementById(`frame${num}`);
            const overlay = document.getElementById(`searching${num}`);
            const card = document.getElementById(`card${num}`);
            const oppText = document.getElementById(`opp${num}`);

            if (!frame || !overlay || !card || !oppText) {
                return;
            }

            const bid = battle.id;
            const battleUrl = getBattleUrl(battle);
            currentBattles[`slot${num}`] = bid;
            currentBattleUrls[`slot${num}`] = battleUrl;
            oppText.textContent = battle.opponent || "----------";

            frame.src = withCacheBust(battleUrl, Date.now());

            overlay.classList.add('hidden');
            frame.classList.add('visible');
            setTimeout(() => card.classList.add('show'), 500);

            scheduleInviteReload(num, bid, battleUrl);
        }

        function resetSlot(num) {
            const frame = document.getElementById(`frame${num}`);
            const overlay = document.getElementById(`searching${num}`);
            const card = document.getElementById(`card${num}`);

            if (!frame || !overlay || !card) {
                return;
            }

            currentBattles[`slot${num}`] = null;
            currentBattleUrls[`slot${num}`] = null;
            clearSlotReloadTimers(num);
            card.classList.remove('show');
            frame.classList.remove('visible');

            setTimeout(() => {
                frame.src = 'about:blank';
                overlay.classList.remove('hidden');
            }, 600);
        }

        function shouldUpdateSlot(num, battle) {
            const currentId = currentBattles[`slot${num}`];
            const currentUrl = currentBattleUrls[`slot${num}`];
            const desiredUrl = getBattleUrl(battle);
            if (currentId !== battle.id) {
                return true;
            }
            if (currentUrl !== desiredUrl) {
                return true;
            }
            return false;
        }

        function syncSlots(battles) {
            const active = battles || [];
            const slotMap = {};
            active.forEach((battle, idx) => {
                const slot = battle.slot || (idx + 1);
                slotMap[slot] = battle;
            });

            if (forceSlot) {
                const slotNum = parseInt(forceSlot);
                const battle = slotMap[slotNum];
                if (battle) {
                    if (shouldUpdateSlot(slotNum, battle)) {
                        updateSlot(slotNum, battle);
                    }
                } else if (currentBattles[`slot${slotNum}`]) {
                    resetSlot(slotNum);
                }
                return;
            }

            [1, 2, 3].forEach((num) => {
                if (num > maxSlots) {
                    if (currentBattles[`slot${num}`]) {
                        resetSlot(num);
                    }
                    return;
                }
                const battle = slotMap[num];
                if (battle) {
                    if (shouldUpdateSlot(num, battle)) {
                        updateSlot(num, battle);
                    }
                } else if (currentBattles[`slot${num}`]) {
                    resetSlot(num);
                }
            });
        }

        function updateStats(data) {
            if (!data) return;
            if (data.wins !== undefined) document.getElementById('totalWins').textContent = data.wins;
            if (data.losses !== undefined) document.getElementById('totalLosses').textContent = data.losses;
            if (data.elo) document.getElementById('totalElo').textContent = data.elo;
        }

        function updateDebug(payload) {
            if (!debugEnabled) return;
            const connText = wsOnline ? 'ONLINE' : 'OFFLINE';
            document.getElementById('debugConn').textContent = `WS: ${connText}`;

            const now = new Date();
            document.getElementById('debugUpdated').textContent = `Last: ${now.toLocaleTimeString()}`;

            const battles = (payload && payload.battles) ? payload.battles : [];
            const slotMap = {};
            battles.forEach((battle, idx) => {
                const slot = battle.slot || (idx + 1);
                slotMap[slot] = battle;
            });

            const s1 = slotMap[1] ? `${slotMap[1].id}` : '-';
            const s2 = slotMap[2] ? `${slotMap[2].id}` : '-';
            document.getElementById('debugSlot1').textContent = `Slot1: ${s1}`;
            document.getElementById('debugSlot2').textContent = `Slot2: ${s2}`;
            const s3 = slotMap[3] ? `${slotMap[3].id}` : '-';
            document.getElementById('debugSlot3').textContent = `Slot3: ${s3}`;
        }

        async function fetchStateFallback() {
            try {
                const resp = await fetch(`${httpBase}/state?t=${Date.now()}`, { cache: 'no-store' });
                const data = await resp.json();
                if (data.status) updateStats(data.status);
                if (data.battles) syncSlots(data.battles);
                updateDebug(data);
            } catch (e) { }
        }

        // Start connection
        connect();

        // Fallback polling if websocket is offline
        setInterval(() => {
            if (!wsOnline) fetchStateFallback();
        }, 5000);

        // Initial sync in case WS is slow to connect
        fetchStateFallback();
    </script>
</body>

</html>
